CURSO DE DJANGO CON PYTHON

SESION 7
1. instalacion de python (descargarlo de org)
2. instalacion de Django PIP herramienta para crear entornos
3. Creacio de entorno prueba con el comando #python -m venv nombreentorno
4. Activar el entorno de desarrollo
	a. entrando a la carpeta scripts de la anterior instalacion
		ejecutamos el archivo activate. 
		Simplemente desde el cmd 
5. Descargar el Django con pip #pip install django
	Siempre con el entorno activado
	Y para cualquier isntalacion de paquete es #pip install nombre
6. Verificacion de paquetes
	con el entorno activo y estando en la carpeta general 
	digitamos #pip freeze --local Este nos desplega lo que 
	tenemos instalado en nuestro proyecto.
	
SESION 8 CREAR PROYECTO  WEB CON DJANGO
1. RECORDAR SIEMPRE ACTIVAR EL ENTORNO DE DESARROLLO
2. para crear un proyecto es:
	Esrtando en la carpeta donde queremos alojar el proyecto 
	digitamos en consola #django-admin startproject nombreproyecto.
3. Verficar si está bien creado el proyecto. Es decir vamos a ver si
	subio en linea el proyecto, estando en la carpeta del proyecto
	digitamos en consola: #python manage.py runserver
	Esto sube el servidor en un servidor local copia la direccion en el 
	navegador y lo revisas

SESION 9 CREACION DEL PRIMER PROYECTO EMPLEADOS

1 Creamos de la misma manera anterior.
	a. crear un entorno virtual llamado empleados
		#python -m venv empleados
	b. instalamos django
		#pip install django
	c. crear el proyecto 
		#django-admin startproject empleado
	d. editor de texto VScode
	
CLASE 10 ARCHIVOS DE UN PROYECTO Django
	
	RECORDAR ACTIVAR EL ENTORNO DEL PROYECTO
	
	a) manage.py = es el principal del proyecto django se encarga de llamar todo lo que 
	se haya implementado en el proyecto. 
	b) settings.py = dentro de todo el se configura todo lo que se necesite para correr
	c) urls.py = llamado al codigo del codigo escrito, porque un priyecto django funciona con
		url
	d) db.sqllite.py = por defecto para las bases de datos cuando no se ha configurado ninguna
	e) _init_.py = hace que se lea todo el codigo de python
	

SESION 11 ARCHIVO URL.py DE DJANGO
	Cuando ingresamos una urlk en el navegador el proyecto busca en urls la referencia que se busca
	una evz encontrado ejectura lo siguiente despues de la coma segun se le haya indicado hacer 
	en esa url.
	
	Se realiza prueba que hacemos para url, agregando una. prueba satisfactoria. Queda Ok
	PARA TENER EN CUENTA:
		- EN LAS URL SON MUICHAS YA QUE CADA VENTANA GENERA CADA VENTANA
		  ES MEJOR QUE EL ARCHIVO PRINCIPAL

SESION 12 Actualizacion por cambio de versión del idioma.

SESION 13 CONFIGURACION/ORGANIZACION DE ARCHIVO SETTING.py

	- Es un archivo que va creciendo a medida que se va desarrollando. 
	- Cada entorno de prueba/testing/ususario/ entorno local etc el archivo va cambiando
		Entonces se debe configurar el archivo para evitar la reconfiguracion de este archivo en 
		los distintos entornos de trabajo. 
		
		a. Creamos una carpeta a nivel del archivo setting.py
		b. Creamos 3 archivos base.py / local.py / prod.py
		c. RECORDAR INCLUIR __init__py, le decimos django que ahi dentro de la carpeta
		hay codigo que debe tener en cuenta
		c. Local: ayduara a usar el proyecto en local.
		python manage.py runserver --settings=empleado.settings.local

SESION 14 QUE SON APLICACIONES EN DJANGO

	desarrollo agil SCRUM,KANBAM,XP
	EN pocas lineas de codigo se obtiene un codigo funcional 
	EN DJANGO SOLCAMENTE PARA CUBRIR UNA NECESIDAD ES DECIR PARA 
	DESPUES INTEGRAR LAS DIFERENTES SOLUCIONES.
	
	VAMOS HACER EL REGISTRO DE EMPLEADOS DE UNA EMPRESA
	ADMINISTRACION DE EMPLEADOS A NIVEL GENERAL.
	
	HACERLO:
	1. SE DEFINE EL DISEÑO (FUNCIONALIDAD) DE BOTONES PESTAÑAS ETC
	2. CREACION DE LA BASE DE DATOS NECESARIA, PARA ESTE CASO SOLO 
		NECESITAMOS DOS TABLAS ASI:
		-	DEPARATAMENTO
			name
			shor_name
		- 	EMPLEADOS
			first_name
			last_name
			job
			departamento (relacion)
			-image
	2. Determinar las app de Django 
		- una app para departamento
		- una app para Empleados

SESION 15 CREACION DE UNA APP 
	 
	 TENER ACTIVO EL ENTORNO (SIEMPRE)
	 
	 1. Crear iuna carpeta llamada aplications a nivel de manage.py
	 2. Estando en aplications ejecutamos el comando django-admin startapp nombreapp
	 3. Creamos dos app departamento y personas
	 
	 Se crean dos carpetas diferentes con archivos cada unoa tiene un archivo llamado
	 migration y ahi es donde se va a guardar los cambios que vaya teniendo nuestra app.
	 
	 
	 ACTUALIZACION !!! al agregar aplicaciones en un proyecto Django.
	 
IMPORTANTE!!!!
Hola, antes de pasar a la siguiente clase por favor ten en cuenta esta pequeña actualización.

Desde la versión 3.2 de Django cambiaron algunas cosas respecto a las aplicaciones y en especifico respecto 
al archivo apps.py que se genera al crear una aplicación. 

Sin no toman en cuenta lo que mencionaré más adelante tendrán problemas al agregar una aplicación local 
al proyecto.

Desde el minuto 1.20 de la siguiente clase, mostramos como agregamos una app local a un proyecto, luego de 
que agreguen la ruta de su aplicación a la variable que contiene aplicaciones de django 
INSTALLED_APPS = [] 

También debemos hacer un paso más.

Nos dirigimos a la aplicación creada y vamos al archivo apps.py dentro encontraremos un código
como este:

from django.apps import AppConfig
  
class DepartamentoConfig(AppConfig):
    default_auto_field = 'django.db.models.BigAutoField'
    name = 'departamento'

aquí, en la variable name, debemos cambiar por la ruta de nuestra aplicación, 
para el ejemplo quedaría de esta forma:

class DepartamentoConfig(AppConfig):
    default_auto_field = 'django.db.models.BigAutoField'
    name = 'applications.departamento'


Este proceso hay que hacerlo para todas las apps que agreguemos a partir de ahora.
 Con ello ya no tendrán problemas al agregar una app.
 
 DECLARAR URLS CON RE_PATH
Como ultimo cambio, también si revisamos el minuto 9:30 de la siguiente clase, 
usamos una función llamada re_path para declarar urls dentro de urls, pero esto ya 
no es necesario desde la versión 3.2, puedes solamente usar la función path, que es 
la que trae ya django por defecto.

SESION 17 INSTALAR UNA APP EN DJANGO

	DEBEMOS DECIRLE A DJANGO QUE TENGA EN CUENTA LAS DOS APP INCIADAS
	cada uno de nuestras carpetas tendra nuestra carpeta url para que nquede mas 
	ordenadas que le correspondan.
	
	entonces en urls.py de departamento agregamos 
	
	from django.contrib import admin
from django.urls import path

def DesdeApp(self):
    print('===================estamos probando URLS.py desde la app deparatamento')

urlpatterns = [
    path('departamento/', DesdeApp),
]

	Y LE HACEMOS REFERENCIA DESDE URLS.PY que es el principal 
	 de la siguiente manera.
	 
	 urlpatterns = [
    path('admin/', admin.site.urls),
    #incluimos url de app departamento
    path ('',include ('aplications.departamento.urls')),
]
	Corremos el navegador y verfiucamos que haya ejecutado lka funcion.
	}
	
SESION 18. PATRO DE DISEÑO, VISTAS TEMPLATE

	POR QUE LAS APP TRAE LA ESTRUCTURA QUE TRAE? DJANGO EN WEB
		
	PATRONES DE DISEÑO: Son estandares para que el codigo esté mas ordenado y abierto a mejorar
	TIPOS DE PROGRAMACION:
	-Programacion en capa:
		base de datos, logica de negocio, presentacion
	-En la web se llama modelo vista controlador (MVC)
		MODELOO ES BASE DE DATOS
		VISTA ES PANTALLA INTERFAZ
		CONTROLADOR ES LA LOGICA DEL NEGOCIO
		
	EN DJANGO ES:
	MDT MODELO VISTA TEMPLATE
	MODELO ES BD
	VISTA ES LOGICA NEGOCIO Y PREPARACION DE DATOS
	TEMPLATE ES EL QUE MUESTRE EN PANTALLA. ESCRIBIENDO SOLO HTML

SESION 19 VISTAS BASADAS EN CLASES
	
	TRABAJAMOS EN MVT
	1. CON EL ENTORNO ACTIVADO 
	2. CREAR UNA NUEVA APP LLAMADA home
		recordemos estando en la carpeta aplications con el comando
		#django-admin startapp home
	VEREMOS PRIMERO COMO TRABAJA LA CAPA VISTA TEMPLETE
	
	
SESION 20 TEORIA DE VISTA GENERICA EN DJANGO|

VISTA GENERICA  ------> TEMPLATE_NAME.html -> debe estar en una carpeta de templates así con 
						todsa las anteriores vistas
				

TEMPLATEVIEW

LISTVIEW

CREATIVEVIEW

UPDATEVIEW

SESION 21 ACTUALIZACION

ACTUALIZACION!! NUEVA VERSION DE DJANGO
Hola, Django lanzo la versión 3.1 y hay pequeños cambios a considerar para evitar errores.

Django 3.1 en cuanto a como va nuestro curso no traerá problemas con excepción de algunos 
detalles en la configuración y otros temas que ya veras en su momento.

En la siguiente clase puede que al realizar los pasos te muestre un error como este al final
 de la terminal: 

'NAME': BASE_DIR / 'db.sqlite3',
TypeError: unsupported operand type(s) for /: 'Path' and 'str'
¿Como lo solucionamos?

Simplemente en el archivo local.py de nuestros settings, debes de dirigirte a la parte de 
DATABASES y cambiarlo por:

DATABASES = {
    'default': {
        'ENGINE': 'django.db.backends.sqlite3',
        'NAME': BASE_DIR.child('db.sqlite3'),
    }
}
¿Por què?

Para esta clase instalamos un paquete llamado unipath el cual con la anterior configuración 
de Django no traía problemas, pero ahora Django usa una nueva configuración en las rutas, 
tema del que sacaré un video en el canal de youtube explicando mejor porque cambio y que 
de bueno trae ese cambio.



¿Por que no cambie todo el video?

Porque usamos sqlite3 solo en estas clases iniciales, luego pasamos a usar un verdadero 
gestos de Base de datos y ahí no hay ningún problema.

SESION 22 TEMPLATES EN VISTAS GENERICAS
VISTAS GENERICAN TRABAJAN BAJO HTML UBICADO EN CARPETA TEMPLATES.

LSA ORDENAREMOS PARA GENERAR UNA SOLA EN TODO EL PROYECTO, ENTONCES A LA ALTURA DE 
manage.py CREAMOS UNA CARPETA LLAMADA TEMPLATES.

2. isntalamos un paquete #pip install unipath

#######################ACLARACION DE CONFIGURACION ADICIONAL DELOS TEMPLATES ############
Efectivamente Django ahora desde la versión 3, trae una nueva herramienta para las 
rutas de los directorios, esto puede remplazar a unipath si lo deseamos, recuerda 
antes que trabajar con unipath sigue siendo opción en django 3, ahora te explico como 
debemos trabajar con este nuevo paquete llamado pathlib.



Primero configuremos el directorio base, aquí debemos especificar a django cuál es el 
directorio base, y esto dependerá de cuál es nuestra configuración, por ejemplo para 
el caso del curso, nosotros creamos una nueva carpeta llamada settings y esto hace que c
ambie nuestro directorio base, como recomendación nuestro directorio base debe ser donde 
está el archivo manage.py, usando pathlib y asumiendo que creamos la carpeta settings la 
configuración de BASE_DIR será:

from pathlib import Path

# cada parent indica cuantas carpetas escalar arriba
BASE_DIR = Path(__file__).resolve().parent.parent.parent


Ahí debemos notar que cada .parent indicamos una carpeta encima de donde está 
el archivo en edición, en este caso hay 3 .parent indicando que la carpeta base 
esta a 3 niveles encima.



Ahora configuremos la ruta base para los templates:

TEMPLATES = [
    {
        'BACKEND': 'django.template.backends.django.DjangoTemplates',
        'DIRS': [BASE_DIR / 'templates' ], # 
        'APP_DIRS': True,
        'OPTIONS': {
            'context_processors': [
                'django.template.context_processors.debug',
                'django.template.context_processors.request',
                'django.contrib.auth.context_processors.auth',
                'django.contrib.messages.context_processors.messages',
            ],
        },
    },
]


Como vemos solo agregamos un / y el nombre de la carpeta, como ya está configurado 
el base este sabrá donde crear la carpeta.

Ahora similar a lo de antes la configuración para la carpeta media y static será:

STATIC_URL = '/static/'
STATICFILES_DIRS = [BASE_DIR / 'static'] # carpeta base static

MEDIA_URL = '/media/'
MEDIA_ROOT = BASE_DIR / 'media' # carpeta base media


###CLASE 23 CONOCIENDO MAS SOBRE LAS VISTAS GENERICAS

USAMOS LISTVIEW PARA PROCESOS DE LISTADO
RECOMENDADA PARA ESO REGISTRO DE BD

####CLASE 24 MODELS PARA VISTAS EN DJANGO

VIMOS COMO TRABJAAN VISTAS GENERICAS DE DJANGO
ES DECIR EN EL TEMPLATE

MODELS.PY nos hace referencia a las BD
No se usa codigo sql ni nada parecido

DJANGO USA ORM usa una capa revio a sql 
es decir escribimos codigo en python sera transformado por medio de la ORM 
a codigo SQL. 

toda interaccion con BD sera escrita en la parte de models.py 
con las dos tablas del ejemplo.

Ahora en models.py de home que es donde estamos trabajando el ejemplo 
aregamos una clase que llamaermos prueba, asi:

class Prueba(models.Model):
    titulo = models.CharField(max_length = 100)
    subtitulo = models.CharField(max_length=50)
    cantidad = models.IntegerField()

    def __str__(Self):
        return self.titulo
		
se pone una funcion que retorna algo una de las variables generalmente.

con lo anterior se creo una tabla BD de la app home

para que se ejecute :

1. en la terminal entorno activo: python manage.py makemigrations --->verifique lo 
nuevo de mi modelos de la app

para que realice la operacion de creacion de la BD en nuestro modelo ejecutamos
python manage.py migrate.

Como ver si tengo realmente creada la BD?
Necesitamos registros

necesitamos el administrads de DJANGO

En este caso en el archivo admin.py registraremos la BD creada de la siguiente manera:
python manage.py migrate.

Creamos un usuario administrador con : python magane.py createsuperusuario y llenamos
los datos solicitados

#####SESION 25 VISTAS GENERICAS Y CONCEPTOS BASICOS

COMO SE INTERACTUAN LAS VISTAS GENERICAS CON NUESTRA BASE DE DATOS

LOQ UE SE HARA ES QUE LOQ UE AGREGAMOS EN EL ADMIN DE DJANGO LO AGREGUE A LA BD 
cada vez que salga QuerySet es porqie es una consulta a BD 
Ques lo que nos retorna ListView, LISTANDONOS todo lo que tenga el modelo prueba
createVew tambein hicimos una practica y como mostar los datos en html para formulario
usando html. ver commit llamado clase 25 actualizado y funcional

<<<<<<< HEAD

PRUEBA DE MODIFICACION DE UN COMMIT ERRONEO 
=======
>>>>>>> af083f3b0a40fa1d8f660ba3225f0b7a1686912b


##### SESION 26 MODELOS EN DJANGO

CONEXION DE DJANGO A CONEXION A BASE DE DATOS.
CON EJEMPLO SIMPLE 
MODELO ES REPRESENTACION DE UNA TABLA DE DATOS.

TIPOS DE CAMPO
CAMPOS OBLIGATORIOS
MODELOS RELACIONADOS
INSTALACION DE POSTGRES
CONEXION A POSTGRES PORQUE ES LA RECOMENDACION DE DJANGO
Y TAMBIEN COMENTAMOS ACERCA DE MySQL

##### SESION 27TIPOS DE CAMPOS DE UN MODELO DE DJANGO

emepzamos por la bd de Departamento

departamento / models

se creó 
class Departamento(models.model):
    name = models.CharField('Nombre', max_length = 50)
    short_name = models.CharField('Nombre Corto', max_length = 20)
    anulate = models.BooleanField('Anulado', default = False)
    


    def __str__(self):
        return self.id + '-' + self.short_name

####SESION 28 PARAMETROS EN LOS CAMPOS DE UN MODELO

VERIFICACION DE MODELO CORRECTO
PREPARO PARA MIGRACION CON EL CODIGO

python manage.py makemigrations


en la carpeta migratios es donde va registrando los cambios que se han realizado
por ejemplo en la anterior comando se creó el modelo Departamento

COMO CMD no arrojó ningun error ahora si lo podemois enviar directamente a la BD real
con el comando #python manage.py migrate.

CAMPO OBLIGATORIO
name = models.CharField('Nombre', max_length = 50)

CAMPO NO OBLIGATORIO
name = models.CharField('Nombre', max_length = 50, blank=true)
													null=true
PARA QUE NO SE REPITA 
													unique=true //irrepetible el parametro
													editable=false//Nadie lo puede editar

####SESION 29 MODELOS RELACIONADOS FOREINGKEY
Como la tabla empleados trae relacianada la tabla departamento
se debe relacionar 

En personas se importa:

from applications.departamento.models import Departamento

Se escribe l foreingKey

departamento = models.ForeignKey(Departamento, on_delete=models.CASCADE)

repetimos el paso de 

PREPARAR MIGRACION Y VERIFICAR CON:
		# python manage.py makemigrations
		
	si no aparece ningun error entonces

ENVIAMOS MIGRACION 
		# python manage.py migrate
		
Levantamos el servidor y vemos como va el desarrollo

#####SESION 3. INSTALACION DE POSTGRESQL EN W10, CREACION DE BD

